### 7.1重排序

重排序：计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排

指令重排对于提高CPU处理性能十分必要，虽然会带来乱序问题，但这点牺牲是值得的



指令重排分为三种

- **编译器优化重排**

  编译器在**不改变单线程程序语义**的前提下，可以重新安排语句的执行顺序

- **指令并行重排**

  现在处理器采用了指令集并行技术来将多条指令重叠执行。如果**不存在数据依赖性**（即后一个执行的语句无需前面执行语句的结果），处理器可以改变语句对应的机器指令的执行顺序

- **内存系统重排**

  由于处理器使用缓存和读写缓冲区，这使得加载（load）和存储（store）操作看上去可能是乱序执行，因为三级缓冲区的存在，导致内存与缓存的同步存在时间差

**指令重排可以保证串行语义一致**，但是**没有义务保证多线程间的语义也一致**。所有多线程下，指令重排序可能会导致一些问题



### 7.2顺序一致性模型和JMM的保证

顺序一致性模型是一个理论模型，内存模型在设计时都会以顺序一致性内存模型作参考



#### 7.2.1数据竞争与顺序一致性

当程序未正确同步时，就可能存在数据竞争

> 数据竞争：在一个线程中写一个变量，在另一个线程中读一个变量，并且写和读没有通过同步来排序

Java内存模型JMM对于正确同步多线程程序的内存一致性做了一下保证

> 如果程序是正确同步的，程序的执行将具有顺序一致性。即程序的执行结果和该程序在顺序一致性模型中执行的结果相同



顺序一致性模型的两大特性

- 一个线程中的所有操作必须按照程序的顺序（即Java代码顺序执行）
- 在顺序一致性模型中，**每个操作必须是原子的，且立刻对所有线程可见**



### 7.3happens-before

happens-before定义

- 如果一个操作happens-before另一个操作，那么第一个操作的可见性将对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前
  - 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before的关系来执行一样，那么JVM也允许这样的重排序