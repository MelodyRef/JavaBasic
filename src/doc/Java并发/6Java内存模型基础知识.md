### 6.1并发编程模型的两个关键问题

- 线程间如何通信？即：线程之间以何种机制来交换信息
- 线程间如何同步？即：线程以何种机制来控制不通线程间操作发生的相对顺序

有两种并发模型可以解决这两个问题

- 消息传递并发模型
- 共享内存并发模型

|                  | 如何通信                                                     | 如何同步                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 消息传递并发模型 | 线程之间**没有公共状态**，线程间的通信必须通过发送信息来显示进行通信 | 发送消息模型天然同步，因为发送消息总是接收消息之前，因此同步是隐式的 |
| 共享内存并发模型 | 线程之间共享程序的公共状态，通过**写-读内存中的公共状态**进行隐式通信 | **必须显示指定某段代码需要在线程之间互斥执行**，同步时显示的 |

Java中使用的时**共享内存并发模型**



### 6.2Java内存模型的抽象结构

#### 6.2.1运行时内存的划分

运行时堆中的变量是共享的，称为共享变量，内存可见性针对的是**共享变量**



#### 6.2.2堆中内存不可见问题

> ​	线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器等

Java线程之间的通信由Java内存模型JMM控制，JMM定义了线程和主内存之间的抽象关系

- 所有的共享变量都存储在主内存中
- 每个线程保存了一份该线程使用到的共享变量的副本
- 如果线程A和线程B之间需要进行通信，必须经历两个步骤
  1. 线程A将线程A更新过的共享变量刷新到主内存中
  2. 线程B到主内存中去读取线程A之前已经更新过的共享变量



**线程之间无法直接访问其他线程内存，线程间通信必须经过主内存，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证**



#### 6.2.3JMM与Java内存区域划分的联系与区别

> 区别：两者是不通的概念层次。JMM是抽象的，用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开。Java内存区域划分是具体的，是JVM运行Java程序时，必要的内存划分
>
> 联系：都存在私有数据区域和共享数据区域。一般来说，JMM的主内存属于共享数据区域，包含了堆和方法区，本地内存属于私有数据区域，包含了本地方法栈，程序计数器，虚拟机栈