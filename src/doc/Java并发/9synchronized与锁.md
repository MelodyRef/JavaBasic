Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁

类锁其实也是对象锁，Java类只有一个Class对象（可以有多个实例对象，这多个实例对象共享这个Class对象）常说的类锁其实就是Class对象锁



### 9.1synchronized关键字

```java
//关键字在实例方法上，锁为当前对象
public synchronized void instancLock(){}

//关键字在静态方法上，锁为Class对象
public static synchronized void classLock(){}

//关键字在代码块上，锁为括号内对象
public void blockLock(){
    Object o  = new Object();
    synchronized(o){
        //
    }
}
```



### 9.2几种锁

Java6之后一个对象有四种锁状态，级别由低到高

1. 无锁
2. 偏向锁
3. 轻量级锁
4. 重量级锁



几种锁会随着竞争状态升级，锁的升级很容易发生，但是锁降级发生的条件比较苛刻，锁降级发生在Stop The World期间，当JVM到达安全点时，会检查是否有闲置的锁，然后进行降级



#### 9.2.1Java对象头

每个Java对象都有对象头，非数组类型2个字宽来存储，数组类型3个字宽存储，32位处理器一个字宽32位，64位处理器一个字宽64位

| 长度     | 内容                   | 说明                       |
| -------- | ---------------------- | -------------------------- |
| 32/64bit | Mark Word              | 存储对象的hashCode或锁信息 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针   |
| 32/64bit | Array length           | 数组的长度（如果是数组）   |

Mark　Word的格式：

| 锁状态   | 29bit或61bit                 | 1bit是否是偏向锁           | 2bit锁标志位 |
| -------- | ---------------------------- | -------------------------- | ------------ |
| 无锁     |                              | 0                          | 01           |
| 偏向锁   | 线程ID                       | 1                          | 01           |
| 轻量级锁 | 指向栈中锁记录的指针         | 此时这一位不用于标记偏向锁 | 00           |
| 重量级锁 | 指向互斥锁（重量级锁）的指针 | 此时这一位不用于标记偏向锁 | 10           |
| GC标记   |                              | 此时这一位不用于标记偏向锁 | 11           |



#### 9.2.2偏向锁

大多数情况下**锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，于是引入偏向锁

偏向锁会偏向于第一个访问锁的线程，如果接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程永远不需要触发同步。也就是说，**偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行效率** (检查对象的偏向锁标志位，为1则无竞争无需走加锁/解锁流程)



##### 实现原理

一个线程在**第一次**进入同步块时，会在对象头和栈帧中的锁记录中存储锁的偏向的线程ID，当下次该线程进入这个同步块时，回去检查锁的Mark Word里面是不是放的自己的线程ID

如果是，表明该线程已经获得了锁，则线程在进入和同步块时不需要花费CAS操作来加锁解锁；不是则代表有另一个线程竞争该锁，这个时候尝试使用CAS操作来替换Mark Word里面的线程ID为新线程的ID，分两种情况

- 成功，表示之前的线程不存在了，Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁
- 失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式竞争锁。

> CAS：Compare and Swap
>
> 比较并设置。用于在硬件层面上提供原子操作。比较是否和给定的值一致，如果一致则修改，不一致则不修改



##### 撤销偏向锁

偏向锁使用了一种**等到竞争出现才释放锁的机制**，当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁

偏向锁在升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，开销很大，过程如下

> 1. 在一个安全点（在这个时间点没有任何字节码正在执行）停止拥有锁的线程
> 2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态
> 3. 唤醒被停止的线程，将当前锁升级成轻量级锁

偏向锁这个默认功能可以关闭

> -XX:UseBiasedLocking=false





#### 9.2.3轻量级锁

多个线程在不通时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况JVM采用轻量级锁来避免线程的阻塞与唤醒

##### 轻量级锁的加锁

**JVM为每个线程在当前线程的栈帧中创建用于存储锁记录的空间（Displaced Mark Word）**，如果一个线程获得锁时发现是**轻量级锁**，会**把锁的Mark Word 复制到自己的锁记录空间**中，然后**线程尝试用CAS将锁的Mark Word替换为指向锁记录的指针**，如果成功，当前线程获得锁，如果失败表示Mark Word已经被替换成了其他线程的锁记录，说明在与其他线程竞争锁，当前线程尝试用自旋来获取锁

> 自旋：不断尝试去获取锁，一般用循环来实现
>
> JDK采用了适应性自旋，如果线程自旋成功获取到了锁，则下次自旋的次数会更多，否则会变得更少
>
> 如果自旋到一定程度（和JVM和操作系统有关）还没获取到锁，称为自旋失败，这个线程会阻塞，同时这个锁升级为重量级锁



##### 轻量级锁的释放

释放锁时，当前线程用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制操作会成功，如果有其他线程因为多次自旋失败导致锁升级为重量级锁，这个CAS操作会失败，此时释放锁并唤醒被阻塞的线程





#### 9.2.4重量级锁

重量级锁依赖于操作系统的互斥量（mutex）实现的，而操作系统中线程间的状态转换需要相当长的时间，所以重量级锁效率很低，但被阻塞线程不会消耗CPU

当多个线程同时请求某个对象锁时,对象锁会设置几种状态来区分请求的线程

> Contention List:所有请求锁的线程将被首先放置到该竞争队列
>
> Entry List：Contention List中那些有资格称为候选人的线程被移到Entry List
>
> Wait Set：那些调用wait被阻塞的线程放到wait set
>
> OnDeck：任何时刻只能有一个线程正在竞争锁，该线程称为OnDeck
>
> Owner:获得锁的线程
>
> ！Owner:释放锁的线程

当一个线程尝试获得锁时，如果该锁已经被占用，则会将线程封装成一个ObjectWaiter对象插入到Contention List的队列队首，然后调用park函数挂起当前线程

当线程释放锁时，会从Contention List或者Entry List中挑选一个线程唤醒，被选中的线程叫做Heir presumptive，即假定继承人，假定继承人会尝试获得锁，但是synchronized是非公平的，所以假定继承人不一定会获得锁，这是由于**重量级锁，线程先自旋尝试获得锁**，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果**自旋不成功再进入等待队列**。这对那些已经在等待队列中的线程来说相对不公平，还有一个不公平的地方在于自旋线程可能会抢了Ready线程的锁



如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object.notify唤醒后会将线程移动到Contention List或者Entry List中。

**当调用一个锁对象的wait或者notify方法时，如果当前锁的状态是偏向锁或者轻量级锁会先膨胀成重量级锁**



#### 9.2.5锁的升级流程总结

每一个线程在准备获取共享资源时：

第一步，检查Mark Word里面是不是存放了自己的线程ID，是代表当前线程处于偏向锁

第二步：如果Mark Word不是自己的线程ID，锁升级，尝试用CAS来执行切换，新的线程根据Mark Word里面现有的ThreadID，通知之前的线程暂停，之前线程将Mark Word里面的内容置为空

第三步：两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接口开始CAS操作，把锁对象的Mark Word的内容修改为自己新建的记录空间的地址方式竞争Mark Word

第四步：第三步成功执行CAS的获得资源，失败的进入自旋

第五步：自旋的线程在自旋过程中，成功获得资源则锁依然处于轻量锁状态

第六步：如果自旋失败，进入重量级锁状态，这个时候自旋的线程进入阻塞，等待之前线程执行完成并唤醒自己

