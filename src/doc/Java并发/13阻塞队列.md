## 阻塞队列

**BlockingQueue**：只管往里面存，取就行，而不用担心多线程环境下存、取共享变量的线程安全问题



### 1.BlockingQueue的操作方法

阻塞队列提供了四组不同的方法用于插入、移出、检查元素：

| 方法\处理方法 | 抛出异常  | 返回特殊值 | 一直阻塞 | 超时退出           |
| ------------- | --------- | ---------- | -------- | ------------------ |
| 插入方法      | add(e)    | offer(e)   | put(e)   | offer(e,time,unit) |
| 移出方法      | remove()  | poll()     | take()   | poll(time,unit)    |
| 检查方法      | element() | peek()     |          |                    |

- **抛出异常**：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列中插入元素，会抛出IllegalStateException("Queue full")异常。当队列为空时，从队列中获取元素会抛出NoSuchElementException
- **返回特殊值**：如果试图的操作无法立即执行，返回一个特殊值，通常时true/false
- **一直阻塞**:如果试图的操作无法立即执行，则一直阻塞或者响应中断
- **超时退出**:如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够成功执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是true/false



特别：

- 不能往阻塞队列中插入null，会抛出空指针异常
- 可以访问阻塞队列中的任意元素，调用remove(o)可以将队列中的特定元素移出，但并高效，尽量避免使用



## 2.BlockingQueue的实现类

#### 1.ArrayBlockingQueue

由数组结构组成的阻塞队列，内部结构是数组，故具有数组的特性

```java
public ArrayBlockingQueue(int capacity,boolean fair){}
```

可以初始化队列大小，且一旦初始化后不能改变。构造方法中的fair代表控制对象的内部锁是否采用公平锁，默认是非公平锁



#### 2.LinkedBlockingQueue

由**链表**结构组成的**有界**阻塞队列。内部结构是链表，具有链表的特性。默认队列大小是Integer.MAX_VALUE,也可以指定大小，此队列按照**先进先出**的原则对元素进行排序



#### 3.DelayedQueue

该队列中的元素只有当其指定的时间到了，才能从队列中取到。注入其中的元素必须实现**Delayed**

DelayedQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞



#### 4.PriorityBlockingQueue

基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定）内部控制线程同步



#### 5.SynchronousQueue

这个队列比较特殊，**没有任何内部容量**，甚至连一个队列的容量都没有。并且每个put必须等待一个take，反之亦然

需要区别容量为一的ArrayBlockingQueue、LinkedBlockingQueue

以下方法的返回值，可以帮助理解这个队列

- iterator()永远返回空，因为里面没有东西
- peek()永远返回null
- put()往queue放进去一个element以后就一直wait直到有其他Thread进来把这个element取走
- offer()往queue里放一个element以后立即返回，如果碰巧这个element被另一个Thread取走就返回true认为offer成功，否则返回false
- take()取出并且remove掉queue队列的element，取不到东西会一直等
- poll()取出并且remove掉queue队列的element，只有碰巧另外一个线程正在往queue里offer或者put数据的时候才会取到东西，否则立即返回null
- isEmpty永远返回true
- remove&removeAll永远返回false



**注意**

PriorityBlockingQueue不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时阻塞消费者。因此使用的时候一定要注意**生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的堆内存空间**，对于使用默认大小的LinkedBlockingQueue也一样